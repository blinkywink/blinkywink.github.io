<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>blinkywink.co</title>
  <link rel="shortcut icon" href="assets/images/darkicon.png" type="image/x-icon">
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Inconsolata:wght@400;500;600;700&display=swap" rel="stylesheet">
  <link rel="stylesheet" href="styles.css">
</head>
<body>
  <!-- Header -->
  <header class="header">
    <div class="header-content">
      <a href="index.html" class="logo" id="logo-link">
        <img src="assets/images/icon.png" alt="icon" class="logo-icon">
        <span class="logo-text">blinkywink.co</span>
      </a>
      <button id="change-username-btn" class="change-username-btn" style="display: none;">Change User</button>
    </div>
  </header>

  <!-- Main Content -->
  <main class="main-content">
    <!-- View Switcher -->
    <div class="stats-view-switcher">
      <button class="view-btn" data-view="tracks">Tracks</button>
      <button class="view-btn" data-view="albums">Albums</button>
      <button class="view-btn" data-view="artists">Artists</button>
    </div>

    <!-- Time Period Selector -->
    <div class="time-period-selector" id="time-period-selector">
      <button class="period-btn active" data-period="overall">all</button>
      <button class="period-btn" data-period="12month">12mo</button>
      <button class="period-btn" data-period="6month">6mo</button>
      <button class="period-btn" data-period="3month">3mo</button>
      <button class="period-btn" data-period="1month">1mo</button>
    </div>

    <!-- Username Input -->
    <div id="username-input" class="username-input-container">
      <div class="username-input-box">
        <h2 class="username-title">Enter Last.fm Username</h2>
        <form id="username-form" class="username-form">
          <input type="text" id="username-field" class="username-field" placeholder="username" required>
          <button type="submit" class="username-submit">Load Stats</button>
        </form>
      </div>
    </div>

    <!-- Loading State -->
    <div id="loading" class="loading-state" style="display: none;">
      <div class="loading-spinner"></div>
      <p>Loading your stats...</p>
    </div>

    <!-- Overview View -->
    <div id="overview-view" class="stats-view active">
      <div class="stats-overview">
        <div class="stat-card">
          <div class="stat-value" id="total-scrobbles">-</div>
          <div class="stat-label">Total Plays</div>
        </div>
        <div class="stat-card">
          <div class="stat-value" id="total-artists">-</div>
          <div class="stat-label">Artists</div>
        </div>
        <div class="stat-card">
          <div class="stat-value" id="total-albums">-</div>
          <div class="stat-label">Albums</div>
        </div>
        <div class="stat-card">
          <div class="stat-value" id="total-tracks">-</div>
          <div class="stat-label">Tracks</div>
        </div>
          </div>
      <div class="now-playing-section">
        <h2 class="section-title" id="now-playing-title">Last Played</h2>
        <div id="now-playing" class="now-playing-list"></div>
      </div>

    </div>

    <!-- Albums View -->
    <div id="albums-view" class="stats-view">
      <div class="summary-card">
        <div class="summary-text">You have listened to <span id="albums-count">-</span> different albums <span id="albums-total-plays">-</span> times.</div>
      </div>
      <h2 class="section-title">Albums</h2>
      <div id="top-albums" class="albums-grid"></div>
    </div>

    <!-- Tracks View -->
    <div id="tracks-view" class="stats-view">
      <div class="summary-card">
        <div class="summary-text">You have listened to <span id="tracks-count">-</span> different tracks <span id="tracks-total-plays">-</span> times.</div>
      </div>
      <h2 class="section-title">Tracks</h2>
      <div id="top-tracks" class="now-playing-list"></div>
    </div>

    <!-- Artists View -->
    <div id="artists-view" class="stats-view">
      <div class="summary-card">
        <div class="summary-text">You have listened to <span id="artists-count">-</span> different artists <span id="artists-total-plays">-</span> times.</div>
      </div>
      <h2 class="section-title">Artists</h2>
      <div id="top-artists" class="artists-list"></div>
    </div>
  </main>

  <!-- Footer -->
  <footer class="footer">
    <div class="footer-content">
      <div class="footer-links">
        <a href="contact/" class="footer-link">Contact</a>
        <a href="about/" class="footer-link">About</a>
      </div>
      <div class="footer-copyright">
        © blinkywink.co
      </div>
    </div>
  </footer>

  <script>
    const LASTFM_API_KEY = '80823e348573d80af66fe59941020fa5';
    let LASTFM_USERNAME = localStorage.getItem('lastfm_username') || '';
    const API_BASE = 'https://ws.audioscrobbler.com/2.0/';

    let currentView = 'overview';
    let currentPeriod = 'overall';
    let currentPage = {
      recent: 1,
      tracks: 1,
      albums: 1,
      artists: 1
    };
    let isLoadingMore = false;

    // Logo click handler - switch to overview
    document.getElementById('logo-link').addEventListener('click', (e) => {
      e.preventDefault();
      switchView('overview');
    });

    // View switching
    document.querySelectorAll('.view-btn').forEach(btn => {
      btn.addEventListener('click', () => {
        const view = btn.dataset.view;
        switchView(view);
      });
    });

    // Logo click handler - switch to overview
    document.getElementById('logo-link').addEventListener('click', (e) => {
      e.preventDefault();
      switchView('overview');
    });

    // Period switching
    document.querySelectorAll('.period-btn').forEach(btn => {
      btn.addEventListener('click', () => {
        const period = btn.dataset.period;
        switchPeriod(period);
      });
    });

    function switchView(view) {
      currentView = view;
      document.querySelectorAll('.view-btn').forEach(btn => {
        btn.classList.toggle('active', btn.dataset.view === view);
      });
      document.querySelectorAll('.stats-view').forEach(v => {
        v.classList.toggle('active', v.id === `${view}-view`);
      });
      
      // Show time period selector for overview, albums, artists, and tracks
      const periodSelector = document.getElementById('time-period-selector');
      if (view === 'overview' || view === 'albums' || view === 'artists' || view === 'tracks') {
        periodSelector.style.display = 'flex';
      } else {
        periodSelector.style.display = 'none';
      }
      
      // Reset page counters when switching views
      currentPage = {
        recent: 1,
        tracks: 1,
        albums: 1,
        artists: 1
      };
      
      loadViewData();
    }

    function switchPeriod(period) {
      currentPeriod = period;
      document.querySelectorAll('.period-btn').forEach(btn => {
        btn.classList.toggle('active', btn.dataset.period === period);
      });
      // Reset page counters when period changes
      currentPage = {
        recent: 1,
        tracks: 1,
        albums: 1,
        artists: 1
      };
      loadViewData();
    }

    async function loadViewData() {
      showLoading();
      try {
        switch(currentView) {
          case 'overview':
            await loadOverview();
            break;
          case 'tracks':
            await loadTopTracks();
            break;
          case 'albums':
            await loadTopAlbums();
            break;
          case 'artists':
            await loadTopArtists();
            break;
        }
      } catch (error) {
        console.error('Error loading data:', error);
        console.error('Error details:', error.message, error.stack);
        showError(`Failed to load data: ${error.message}. Please check the console for details.`);
      } finally {
        hideLoading();
      }
    }

    async function fetchAPI(method, params = {}) {
      try {
        if (!LASTFM_USERNAME && method.startsWith('user.')) {
          throw new Error('No username set');
        }
        const queryParams = new URLSearchParams({
          method,
          api_key: LASTFM_API_KEY,
          format: 'json'
        });
        
        // Add user parameter for user.* methods
        if (method.startsWith('user.') && LASTFM_USERNAME) {
          queryParams.set('user', LASTFM_USERNAME);
        }
        
        // Add other params (excluding username if it's not a user.* method)
        Object.keys(params).forEach(key => {
          if (key !== 'username' || method.startsWith('user.')) {
            queryParams.set(key, params[key]);
          }
        });
        
        const response = await fetch(`${API_BASE}?${queryParams}`);
        if (!response.ok) {
          throw new Error(`API request failed: ${response.status}`);
        }
        const data = await response.json();
        if (data.error) {
          throw new Error(`Last.fm API error: ${data.message || data.error}`);
        }
        return data;
      } catch (error) {
        // Don't log errors for artist.getInfo and track.getInfo - they're handled by the caller
        if (method !== 'artist.getInfo' && method !== 'track.getInfo') {
          console.error(`API error for ${method}:`, error);
        }
        throw error;
      }
    }

    async function loadOverviewTracks(playedTracks) {
      // Check if overview view is active
      const overviewView = document.getElementById('overview-view');
      if (!overviewView || !overviewView.classList.contains('active')) {
        return; // Don't update if view is not active
      }
      
      const nowPlayingDiv = document.getElementById('now-playing');
      if (!nowPlayingDiv) {
        return; // Element doesn't exist
      }
      
      if (playedTracks && playedTracks.length > 0) {
        // Get most recent track for the title
        const mostRecent = playedTracks[0];
        let dateText = '';
        if (mostRecent && mostRecent.date && mostRecent.date['#text']) {
          dateText = formatDate(mostRecent.date['#text']);
        }
        
        const titleElement = document.getElementById('now-playing-title');
        if (titleElement) {
          titleElement.textContent = 'Last Played';
        }
        
        const updateElement = document.getElementById('now-playing-update');
        if (updateElement) {
          updateElement.textContent = dateText ? `updated ${dateText}` : '';
        }
        
        // Get playcounts from user.getTopTracks (EXACT same as tracks view)
        const topTracksData = await fetchAPI('user.getTopTracks', { period: 'overall', limit: 1000 }).catch(() => ({ toptracks: { track: [] } }));
        const topTracksMap = new Map();
        if (topTracksData.toptracks && topTracksData.toptracks.track) {
          const topTracks = Array.isArray(topTracksData.toptracks.track) 
            ? topTracksData.toptracks.track 
            : [topTracksData.toptracks.track];
          topTracks.forEach(t => {
            const key = `${(t.artist.name || '').toLowerCase()}|${(t.name || '').toLowerCase()}`;
            topTracksMap.set(key, parseInt(t.playcount || 0));
          });
        }
        
        const html = playedTracks.map((track, index) => {
          const image = getImageUrl(track.image, 'extralarge');
          const artistName = track.artist['#text'] || track.artist.name || 'Unknown Artist';
          const trackName = track.name || 'Unknown Track';
          const albumName = track.album['#text'] || track.album || 'Unknown Album';
          
          // Get playcount from top tracks map (EXACT same as tracks view)
          const key = `${artistName.toLowerCase()}|${trackName.toLowerCase()}`;
          const playcount = topTracksMap.get(key) || 0;
          
          return `
            <a href="${getArtistUrl(artistName)}" class="now-playing-card">
              <div class="now-playing-content">
                <div class="image-loading-container">
                  <div class="image-loading-spinner"></div>
                  <img src="${image}" alt="${trackName}" class="now-playing-image" onload="this.classList.add('loaded'); this.parentElement.querySelector('.image-loading-spinner').style.display='none';" onerror="this.classList.add('loaded'); this.parentElement.querySelector('.image-loading-spinner').style.display='none'; this.style.display='none';">
                </div>
                <div class="now-playing-info">
                  <div class="now-playing-track">${escapeHtml(trackName)}</div>
                  <div class="now-playing-artist">${escapeHtml(artistName)}</div>
                  <div class="now-playing-album">${escapeHtml(albumName)}</div>
                </div>
              </div>
            </a>
          `;
        }).join('');
        
        nowPlayingDiv.innerHTML = html;
      } else {
        nowPlayingDiv.innerHTML = '<div class="now-playing-placeholder">No recent tracks</div>';
      }
    }

    async function loadOverview() {
      try {
        if (!LASTFM_USERNAME) {
          throw new Error('No username set');
        }
        
        const [userInfo, recentTracks, topArtists, topAlbums, topTracks] = await Promise.all([
          fetchAPI('user.getInfo'),
          fetchAPI('user.getRecentTracks', { limit: 3 }),
          fetchAPI('user.getTopArtists', { period: currentPeriod, limit: 1 }),
          fetchAPI('user.getTopAlbums', { period: currentPeriod, limit: 1 }),
          fetchAPI('user.getTopTracks', { period: currentPeriod, limit: 1 })
        ]);

        if (!userInfo || !userInfo.user) {
          console.error('userInfo response:', userInfo);
          throw new Error('Failed to load user info');
        }

        const user = userInfo.user;
        
        // Get stats from period-specific data
        let totalScrobbles = parseInt(user.playcount || 0);
        let totalArtists = parseInt(user.artist_count || 0);
        let totalAlbums = parseInt(user.album_count || 0);
        let totalTracks = parseInt(user.track_count || 0);
        
        // If period is not overall, fetch more data to get accurate counts
        if (currentPeriod !== 'overall') {
          const [fullTopArtists, fullTopAlbums, fullTopTracks] = await Promise.all([
            fetchAPI('user.getTopArtists', { period: currentPeriod, limit: 1000 }),
            fetchAPI('user.getTopAlbums', { period: currentPeriod, limit: 1000 }),
            fetchAPI('user.getTopTracks', { period: currentPeriod, limit: 1000 })
          ]);
          
          // Count unique artists and sum playcounts
          if (fullTopArtists.topartists && fullTopArtists.topartists.artist) {
            const artists = Array.isArray(fullTopArtists.topartists.artist) 
              ? fullTopArtists.topartists.artist 
              : [fullTopArtists.topartists.artist];
            totalArtists = artists.length;
            // Sum playcounts for scrobbles
            totalScrobbles = artists.reduce((sum, a) => sum + parseInt(a.playcount || 0), 0);
          } else {
            // If no artists returned, set to 0
            totalArtists = 0;
            totalScrobbles = 0;
          }
          
          // Count unique albums
          if (fullTopAlbums.topalbums && fullTopAlbums.topalbums.album) {
            const albums = Array.isArray(fullTopAlbums.topalbums.album) 
              ? fullTopAlbums.topalbums.album 
              : [fullTopAlbums.topalbums.album];
            totalAlbums = albums.length;
          } else {
            totalAlbums = 0;
          }
          
          // Count unique tracks
          if (fullTopTracks.toptracks && fullTopTracks.toptracks.track) {
            const tracks = Array.isArray(fullTopTracks.toptracks.track) 
              ? fullTopTracks.toptracks.track 
              : [fullTopTracks.toptracks.track];
            totalTracks = tracks.length;
          } else {
            totalTracks = 0;
          }
        }
        
        // Check if overview view is active before updating
        const overviewView = document.getElementById('overview-view');
        if (overviewView && overviewView.classList.contains('active')) {
          const totalScrobblesEl = document.getElementById('total-scrobbles');
          const totalArtistsEl = document.getElementById('total-artists');
          const totalAlbumsEl = document.getElementById('total-albums');
          const totalTracksEl = document.getElementById('total-tracks');
          
          if (totalScrobblesEl) totalScrobblesEl.textContent = totalScrobbles.toLocaleString();
          if (totalArtistsEl) totalArtistsEl.textContent = totalArtists.toLocaleString();
          if (totalAlbumsEl) totalAlbumsEl.textContent = totalAlbums.toLocaleString();
          if (totalTracksEl) totalTracksEl.textContent = totalTracks.toLocaleString();
        }

        // Show last played tracks
        if (recentTracks.recenttracks && recentTracks.recenttracks.track) {
          const tracks = Array.isArray(recentTracks.recenttracks.track) 
            ? recentTracks.recenttracks.track 
            : [recentTracks.recenttracks.track];
          
          // Filter out now playing tracks
          const playedTracks = tracks.filter(t => !t['@attr'] || !t['@attr'].nowplaying);
          await loadOverviewTracks(playedTracks);
        } else {
          const nowPlayingDiv = document.getElementById('now-playing');
          nowPlayingDiv.innerHTML = '<div class="now-playing-placeholder">No recent tracks</div>';
        }
      } catch (error) {
        console.error('Error in loadOverview:', error);
        throw error;
      }
    }

    async function loadRecentTracks(page = 1, append = false) {
      const limit = 50;
      const data = await fetchAPI('user.getRecentTracks', { limit: limit, page: page });
      const tracks = data.recenttracks.track;
      const tracksList = document.getElementById('recent-tracks');
      
      if (!tracks || tracks.length === 0) {
        if (!append) {
          tracksList.innerHTML = '<div class="empty-state">No recent tracks found</div>';
        }
        return;
      }

      const trackArray = Array.isArray(tracks) ? tracks : [tracks];
      const html = trackArray.map(track => {
        const image = getImageUrl(track.image, 'extralarge');
        const isNowPlaying = track['@attr'] && track['@attr'].nowplaying === 'true';
        const dateText = isNowPlaying ? 'Now playing' : (track.date && track.date['#text'] ? formatDate(track.date['#text']) : '');
        const artistName = track.artist['#text'] || track.artist.name || 'Unknown Artist';
        const trackName = track.name || 'Unknown Track';
        const albumName = track.album['#text'] || track.album || 'Unknown Album';
        
        return `
          <a href="${getTrackUrl(artistName, trackName)}" class="track-item-link">
            <div class="track-item ${isNowPlaying ? 'now-playing-track' : ''}">
              <div class="track-image-container">
                <div class="image-loading-spinner"></div>
                <img src="${image}" alt="${trackName}" class="track-image" onload="this.classList.add('loaded'); this.parentElement.querySelector('.image-loading-spinner').style.display='none';" onerror="this.classList.add('loaded'); this.parentElement.querySelector('.image-loading-spinner').style.display='none'; this.style.display='none';">
              </div>
              <div class="track-info">
                <div class="track-name">${escapeHtml(trackName)}</div>
                <div class="track-artist">${escapeHtml(artistName)}</div>
                <div class="track-album">${escapeHtml(albumName)}</div>
              </div>
              <div class="track-meta">
                ${isNowPlaying ? '<span class="now-playing-badge">▶</span>' : ''}
                <div class="track-date">${dateText}</div>
              </div>
            </div>
          </a>
        `;
      }).join('');
      
      if (append) {
        tracksList.innerHTML += html;
      } else {
        tracksList.innerHTML = html;
      }
      
      currentPage.recent = page;
    }

    async function loadTopTracks(page = 1, append = false) {
      const limit = 50;
      const data = await fetchAPI('user.getTopTracks', { period: currentPeriod, limit: limit, page: page });
      const tracks = data.toptracks.track;
      const tracksList = document.getElementById('top-tracks');
      
      if (!tracks || tracks.length === 0) {
        if (!append) {
          tracksList.innerHTML = '<div class="empty-state">No tracks found</div>';
        }
        return;
      }

      const trackArray = Array.isArray(tracks) ? tracks : [tracks];
      
      // Update summary card (only on first page) - need to fetch all to get accurate totals
      if (page === 1) {
        const totalTracks = parseInt(data.toptracks['@attr']?.total || trackArray.length);
        let totalPlays;
        
        // For "all time" period, use total scrobbles from user.getInfo
        if (currentPeriod === 'overall') {
          const userInfo = await fetchAPI('user.getInfo');
          totalPlays = parseInt(userInfo.user?.playcount || 0);
        } else {
          // For other periods, sum all playcounts - fetch pages with rate limiting
          totalPlays = trackArray.reduce((sum, t) => sum + parseInt(t.playcount || 0), 0);
          if (totalTracks > limit) {
            const totalPages = Math.ceil(totalTracks / limit);
            // Limit to reasonable number of pages to avoid API errors (max 50 pages = 2500 tracks)
            const maxPages = Math.min(totalPages, 50);
            for (let p = 2; p <= maxPages; p++) {
              try {
                // Add small delay to avoid rate limiting
                if (p > 2) await new Promise(resolve => setTimeout(resolve, 100));
                const moreData = await fetchAPI('user.getTopTracks', { period: currentPeriod, limit: limit, page: p });
                if (moreData.toptracks && moreData.toptracks.track) {
                  const moreTracks = Array.isArray(moreData.toptracks.track) ? moreData.toptracks.track : [moreData.toptracks.track];
                  totalPlays += moreTracks.reduce((sum, t) => sum + parseInt(t.playcount || 0), 0);
                }
              } catch (e) {
                console.warn(`Failed to fetch page ${p} for tracks:`, e);
                break;
              }
            }
          }
        }
        document.getElementById('tracks-count').textContent = totalTracks.toLocaleString();
        document.getElementById('tracks-total-plays').textContent = totalPlays.toLocaleString();
      }
      
      // Fetch track info to get album images
      const trackInfoPromises = trackArray.map(track => 
        fetchAPI('track.getInfo', { 
          artist: track.artist.name, 
          track: track.name,
          username: LASTFM_USERNAME 
        }).catch(() => null)
      );
      const trackInfos = await Promise.all(trackInfoPromises);
      
      const html = trackArray.map((track, index) => {
        let image = 'https://via.placeholder.com/80';
        let albumName = 'Unknown Album';
        // Try to get album image and name from track info
        if (trackInfos[index] && trackInfos[index].track && trackInfos[index].track.album) {
          const album = trackInfos[index].track.album;
          albumName = album.title || 'Unknown Album';
          const albumImage = album.image;
          if (albumImage && albumImage.length > 0) {
            image = getImageUrl(albumImage, 'extralarge');
          }
        }
        // Fallback to track.image if available
        if (!image || image.includes('placeholder')) {
          const trackImg = getImageUrl(track.image, 'extralarge');
          if (trackImg && !trackImg.includes('placeholder')) {
            image = trackImg;
          }
        }
        
        const artistName = track.artist.name || 'Unknown Artist';
        const trackName = track.name || 'Unknown Track';
        const playcount = parseInt(track.playcount || 0);
        
        return `
          <a href="${getTrackUrl(artistName, trackName)}" class="now-playing-card">
            <div class="now-playing-content">
              <div class="image-loading-container">
                <div class="image-loading-spinner"></div>
                <img src="${image}" alt="${trackName}" class="now-playing-image" onload="this.classList.add('loaded'); this.parentElement.querySelector('.image-loading-spinner').style.display='none';" onerror="this.classList.add('loaded'); this.parentElement.querySelector('.image-loading-spinner').style.display='none'; this.style.display='none';">
              </div>
              <div class="now-playing-info">
                <div class="now-playing-track">${escapeHtml(trackName)}</div>
                <div class="now-playing-artist">${escapeHtml(artistName)}</div>
                <div class="now-playing-album">${escapeHtml(albumName)}</div>
              </div>
              <div class="now-playing-plays">${playcount.toLocaleString()} ${playcount === 1 ? 'play' : 'plays'}</div>
            </div>
          </a>
        `;
      }).join('');
      
      if (append) {
        tracksList.innerHTML += html;
      } else {
        tracksList.innerHTML = html;
      }
      
      currentPage.tracks = page;
    }

    async function loadTopAlbums(page = 1, append = false) {
      const limit = 50;
      const data = await fetchAPI('user.getTopAlbums', { period: currentPeriod, limit: limit, page: page });
      const albums = data.topalbums.album;
      const albumsGrid = document.getElementById('top-albums');
      
      if (!albums || albums.length === 0) {
        if (!append) {
          albumsGrid.innerHTML = '<div class="empty-state">No albums found</div>';
        }
        return;
      }

      const albumArray = Array.isArray(albums) ? albums : [albums];
      
      // Update summary card (only on first page) - need to fetch all to get accurate totals
      if (page === 1) {
        const totalAlbums = parseInt(data.topalbums['@attr']?.total || albumArray.length);
        let totalPlays;
        
        // For "all time" period, use total scrobbles from user.getInfo
        if (currentPeriod === 'overall') {
          const userInfo = await fetchAPI('user.getInfo');
          totalPlays = parseInt(userInfo.user?.playcount || 0);
        } else {
          // For other periods, sum all playcounts - fetch pages with rate limiting
          totalPlays = albumArray.reduce((sum, a) => sum + parseInt(a.playcount || 0), 0);
          if (totalAlbums > limit) {
            const totalPages = Math.ceil(totalAlbums / limit);
            // Limit to reasonable number of pages to avoid API errors (max 50 pages = 2500 albums)
            const maxPages = Math.min(totalPages, 50);
            for (let p = 2; p <= maxPages; p++) {
              try {
                // Add small delay to avoid rate limiting
                if (p > 2) await new Promise(resolve => setTimeout(resolve, 100));
                const moreData = await fetchAPI('user.getTopAlbums', { period: currentPeriod, limit: limit, page: p });
                if (moreData.topalbums && moreData.topalbums.album) {
                  const moreAlbums = Array.isArray(moreData.topalbums.album) ? moreData.topalbums.album : [moreData.topalbums.album];
                  totalPlays += moreAlbums.reduce((sum, a) => sum + parseInt(a.playcount || 0), 0);
                }
              } catch (e) {
                console.warn(`Failed to fetch page ${p} for albums:`, e);
                break;
              }
            }
          }
        }
        document.getElementById('albums-count').textContent = totalAlbums.toLocaleString();
        document.getElementById('albums-total-plays').textContent = totalPlays.toLocaleString();
      }
      const html = albumArray.map(album => {
        const image = getImageUrl(album.image, 'extralarge');
        const albumName = album.name || 'Unknown Album';
        const artistName = album.artist.name || 'Unknown Artist';
        
        return `
          <a href="${getAlbumUrl(artistName, albumName)}" class="album-card-link">
            <div class="album-card">
              <div class="album-cover-container">
                <div class="image-loading-spinner"></div>
                <img src="${image}" alt="${albumName}" class="album-cover" onload="this.classList.add('loaded'); this.parentElement.querySelector('.image-loading-spinner').style.display='none';" onerror="this.classList.add('loaded'); this.parentElement.querySelector('.image-loading-spinner').style.display='none'; this.style.display='none';">
              </div>
              <div class="album-info">
                <div class="album-name">${escapeHtml(albumName)}</div>
                <div class="album-artist">${escapeHtml(artistName)}</div>
                <div class="album-plays">${parseInt(album.playcount || 0).toLocaleString()} plays</div>
              </div>
            </div>
          </a>
        `;
      }).join('');
      
      if (append) {
        albumsGrid.innerHTML += html;
      } else {
        albumsGrid.innerHTML = html;
      }
      
      currentPage.albums = page;
    }

    async function loadTopArtists(page = 1, append = false) {
      const limit = 50;
      const data = await fetchAPI('user.getTopArtists', { period: currentPeriod, limit: limit, page: page });
      const artists = data.topartists.artist;
      const artistsList = document.getElementById('top-artists');
      
      if (!artists || artists.length === 0) {
        if (!append) {
          artistsList.innerHTML = '<div class="empty-state">No artists found</div>';
        }
        return;
      }

      const artistArray = Array.isArray(artists) ? artists : [artists];
      
      // Update summary card (only on first page) - need to fetch all to get accurate totals
      if (page === 1) {
        const totalArtists = parseInt(data.topartists['@attr']?.total || artistArray.length);
        let totalPlays;
        
        // For "all time" period, use total scrobbles from user.getInfo
        if (currentPeriod === 'overall') {
          const userInfo = await fetchAPI('user.getInfo');
          totalPlays = parseInt(userInfo.user?.playcount || 0);
        } else {
          // For other periods, sum all playcounts - fetch pages with rate limiting
          totalPlays = artistArray.reduce((sum, a) => sum + parseInt(a.playcount || 0), 0);
          if (totalArtists > limit) {
            const totalPages = Math.ceil(totalArtists / limit);
            // Limit to reasonable number of pages to avoid API errors (max 50 pages = 2500 artists)
            const maxPages = Math.min(totalPages, 50);
            for (let p = 2; p <= maxPages; p++) {
              try {
                // Add small delay to avoid rate limiting
                if (p > 2) await new Promise(resolve => setTimeout(resolve, 100));
                const moreData = await fetchAPI('user.getTopArtists', { period: currentPeriod, limit: limit, page: p });
                if (moreData.topartists && moreData.topartists.artist) {
                  const moreArtists = Array.isArray(moreData.topartists.artist) ? moreData.topartists.artist : [moreData.topartists.artist];
                  totalPlays += moreArtists.reduce((sum, a) => sum + parseInt(a.playcount || 0), 0);
                }
              } catch (e) {
                console.warn(`Failed to fetch page ${p} for artists:`, e);
                break;
              }
            }
          }
        }
        document.getElementById('artists-count').textContent = totalArtists.toLocaleString();
        document.getElementById('artists-total-plays').textContent = totalPlays.toLocaleString();
      }
      
      // Fetch artist info for images - EXACT SAME METHOD AS ARTIST PAGE (line 145-162)
      const [userTopAlbums] = await Promise.all([
        fetchAPI('user.getTopAlbums', { user: LASTFM_USERNAME, limit: 1000 }).catch(() => {
          return { topalbums: { album: [] } };
        })
      ]);
      
      const artistPromises = artistArray.map(artist => 
        fetchAPI('artist.getInfo', { artist: artist.name, username: LASTFM_USERNAME }).catch(err => {
          return { error: true, message: err.message };
        })
      );
      const artistInfos = await Promise.all(artistPromises);
      
      const html = artistArray.map((artist, index) => {
        const artistName = artist.name || 'Unknown Artist';
        
        // Get image - EXACT SAME LOGIC AS ARTIST PAGE (line 176-190)
        let image = '';
        if (artistInfos[index] && !artistInfos[index].error && artistInfos[index].artist) {
          const artistData = artistInfos[index].artist;
          // First try artist image - EXACT SAME AS ARTIST PAGE LINE 176
          image = getImageUrl(artistData.image, 'extralarge'); // Use extralarge for list view (artist page uses mega)
          // Check if it's placeholder, empty, or Last.fm generic placeholder - EXACT SAME CHECK AS ARTIST PAGE LINE 177
          if (!image || image.includes('placeholder') || image === '' || image === 'https://via.placeholder.com/300' || image.includes('2a96cbd8b46e442fc41c2b86b821562f')) {
            // Try to get image from top albums - filter by this specific artist
            if (userTopAlbums.topalbums && userTopAlbums.topalbums.album) {
              const albums = Array.isArray(userTopAlbums.topalbums.album) 
                ? userTopAlbums.topalbums.album 
                : [userTopAlbums.topalbums.album];
              // Find albums for THIS specific artist (not just first album)
              const artistAlbums = albums.filter(album => {
                const albumArtist = album.artist && album.artist.name ? album.artist.name : (album.artist || '');
                return albumArtist && albumArtist.toLowerCase() === artistName.toLowerCase();
              });
              if (artistAlbums.length > 0 && artistAlbums[0].image) {
                const albumImg = getImageUrl(artistAlbums[0].image, 'extralarge');
                if (albumImg && !albumImg.includes('placeholder') && albumImg !== 'https://via.placeholder.com/300') {
                  image = albumImg;
                }
              }
            }
          }
        }
        
        // If still no valid image, use data URI placeholder
        if (!image || image.trim() === '') {
          image = 'data:image/svg+xml,%3Csvg xmlns=\'http://www.w3.org/2000/svg\' width=\'300\' height=\'300\'%3E%3Crect fill=\'%23333\' width=\'300\' height=\'300\'/%3E%3C/svg%3E';
        }
        
        return `
          <a href="${getArtistUrl(artistName)}" class="artist-item-link">
            <div class="artist-item">
              <div class="artist-rank">#${(page - 1) * limit + index + 1}</div>
              <div class="artist-image-container">
                <div class="image-loading-spinner"></div>
                <img src="${image}" alt="${artistName}" class="artist-image" onload="this.classList.add('loaded'); this.parentElement.querySelector('.image-loading-spinner').style.display='none';" onerror="this.classList.add('loaded'); this.parentElement.querySelector('.image-loading-spinner').style.display='none'; this.style.display='none';">
              </div>
              <div class="artist-info">
                <div class="artist-name">${escapeHtml(artistName)}</div>
                <div class="artist-plays">${parseInt(artist.playcount || 0).toLocaleString()} plays</div>
              </div>
            </div>
          </a>
        `;
      }).join('');
      
      if (append) {
        artistsList.innerHTML += html;
      } else {
        artistsList.innerHTML = html;
      }
      
      currentPage.artists = page;
    }

    function showLoading() {
      document.getElementById('loading').style.display = 'flex';
    }

    function hideLoading() {
      document.getElementById('loading').style.display = 'none';
    }

    function showError(message) {
      const views = document.querySelectorAll('.stats-view');
      views.forEach(view => {
        if (view.classList.contains('active')) {
          view.innerHTML = `<div class="error-state">${message}</div>`;
        }
      });
    }

    function escapeHtml(text) {
      const div = document.createElement('div');
      div.textContent = text;
      return div.innerHTML;
    }

    function formatDate(dateString) {
      if (!dateString) return '';
      
      // Last.fm returns dates in format like "1 Jan 2024, 12:34" or Unix timestamp
      let date;
      if (typeof dateString === 'number' || /^\d+$/.test(dateString)) {
        // Unix timestamp
        date = new Date(parseInt(dateString) * 1000);
      } else {
        // Try parsing as date string
        date = new Date(dateString);
      }
      
      // Check if date is valid
      if (isNaN(date.getTime())) {
        return dateString; // Return original string if parsing failed
      }
      
      const now = new Date();
      const diffMs = now - date;
      
      // If negative difference, the date is in the future (shouldn't happen but handle it)
      if (diffMs < 0) {
        return date.toLocaleDateString();
      }
      
      const diffMins = Math.floor(diffMs / 60000);
      const diffHours = Math.floor(diffMs / 3600000);
      const diffDays = Math.floor(diffMs / 86400000);

      const diffWeeks = Math.floor(diffDays / 7);
      const diffMonths = Math.floor(diffDays / 30);

      if (diffMins < 1) return 'moments ago';
      if (diffMins < 60) return `${diffMins} ${diffMins === 1 ? 'minute' : 'minutes'} ago`;
      if (diffHours < 24) return `${diffHours} ${diffHours === 1 ? 'hour' : 'hours'} ago`;
      if (diffDays < 7) return `${diffDays} ${diffDays === 1 ? 'day' : 'days'} ago`;
      if (diffWeeks < 4) return `${diffWeeks} ${diffWeeks === 1 ? 'week' : 'weeks'} ago`;
      if (diffMonths < 12) return `${diffMonths} ${diffMonths === 1 ? 'month' : 'months'} ago`;
      return date.toLocaleDateString();
    }

    function getImageUrl(imageArray, size = 'large') {
      if (!imageArray || !Array.isArray(imageArray) || imageArray.length === 0) {
        return '';
      }
      
      // Last.fm image sizes: [small, medium, large, extralarge, mega]
      // size can be: 'small' (34x34), 'medium' (64x64), 'large' (174x174), 'extralarge' (300x300), 'mega' (600x600)
      let imageIndex = 2; // default to large
      if (size === 'small') imageIndex = 0;
      else if (size === 'medium') imageIndex = 1;
      else if (size === 'large') imageIndex = 2;
      else if (size === 'extralarge') imageIndex = 3;
      else if (size === 'mega') imageIndex = 4;
      
      // Try to get the requested size first
      let targetIndex = Math.min(imageIndex, imageArray.length - 1);
      let image = imageArray[targetIndex];
      let url = image && image['#text'] ? image['#text'] : '';
      
      // If the requested size is empty, try to find any non-empty image starting from the requested size
      if (!url || url.trim() === '') {
        for (let i = targetIndex; i < imageArray.length; i++) {
          const img = imageArray[i];
          if (img && img['#text'] && img['#text'].trim() !== '') {
            url = img['#text'];
            break;
          }
        }
      }
      
      // If still no URL, try going backwards from requested size
      if (!url || url.trim() === '') {
        for (let i = targetIndex - 1; i >= 0; i--) {
          const img = imageArray[i];
          if (img && img['#text'] && img['#text'].trim() !== '') {
            url = img['#text'];
            break;
          }
        }
      }
      
      // Return empty string if no URL found - let caller handle fallback
      return url && url.trim() !== '' ? url : '';
    }

    function getArtistUrl(artistName) {
      return `artist/?artist=${encodeURIComponent(artistName)}`;
    }

    function getAlbumUrl(artistName, albumName) {
      // Redirect to artist page instead of album page
      return `artist/?artist=${encodeURIComponent(artistName)}`;
    }

    function getTrackUrl(artistName, trackName) {
      // Redirect to artist page instead of track page
      return `artist/?artist=${encodeURIComponent(artistName)}`;
    }

    // Register service worker for image caching
    if ('serviceWorker' in navigator) {
      window.addEventListener('load', () => {
        navigator.serviceWorker.register('/service-worker.js')
          .then((registration) => {
            console.log('Service Worker registered:', registration.scope);
          })
          .catch((error) => {
            console.log('Service Worker registration failed:', error);
          });
      });
    }

    // Infinite scroll handler
    function setupInfiniteScroll() {
      window.addEventListener('scroll', () => {
        if (isLoadingMore) return;
        
        const scrollTop = window.pageYOffset || document.documentElement.scrollTop;
        const windowHeight = window.innerHeight;
        const documentHeight = document.documentElement.scrollHeight;
        
        // Load more when 200px from bottom
        if (scrollTop + windowHeight >= documentHeight - 200) {
          isLoadingMore = true;
          
          if (currentView === 'overview') {
            // Load more recent tracks for overview
            const currentCount = document.querySelectorAll('.now-playing-card').length;
            fetchAPI('user.getRecentTracks', { limit: currentCount + 10 })
              .then(data => {
                if (data.recenttracks && data.recenttracks.track) {
                  const tracks = Array.isArray(data.recenttracks.track) 
                    ? data.recenttracks.track 
                    : [data.recenttracks.track];
                  const playedTracks = tracks.filter(t => !t['@attr'] || !t['@attr'].nowplaying);
                  const nowPlayingDiv = document.getElementById('now-playing');
                  const existingHtml = nowPlayingDiv.innerHTML;
                  const newTracks = playedTracks.slice(currentCount);
                  // Fetch track info for playcounts
                  const trackInfoPromises = newTracks.map(track => 
                    fetchAPI('track.getInfo', { 
                      artist: track.artist['#text'] || track.artist.name, 
                      track: track.name,
                      username: LASTFM_USERNAME 
                    }).catch(() => null)
                  );
                  Promise.all(trackInfoPromises).then(trackInfos => {
                    const newHtml = newTracks.map((track, index) => {
                      const image = getImageUrl(track.image, 'extralarge');
                      const artistName = track.artist['#text'] || track.artist.name || 'Unknown Artist';
                      const trackName = track.name || 'Unknown Track';
                      const albumName = track.album['#text'] || track.album || 'Unknown Album';
                      
                      let playcount = 0;
                      if (trackInfos[index] && trackInfos[index].track && trackInfos[index].track.userplaycount) {
                        playcount = parseInt(trackInfos[index].track.userplaycount || 0);
                      }
                      
                      return `
                        <a href="${getArtistUrl(artistName)}" class="now-playing-card">
                          <div class="now-playing-content">
                            <div class="image-loading-container">
                              <div class="image-loading-spinner"></div>
                              <img src="${image}" alt="${trackName}" class="now-playing-image" onload="this.classList.add('loaded'); this.parentElement.querySelector('.image-loading-spinner').style.display='none';" onerror="this.classList.add('loaded'); this.parentElement.querySelector('.image-loading-spinner').style.display='none'; this.style.display='none';">
                            </div>
                            <div class="now-playing-info">
                              <div class="now-playing-track">${escapeHtml(trackName)}</div>
                              <div class="now-playing-artist">${escapeHtml(artistName)}</div>
                              <div class="now-playing-album">${escapeHtml(albumName)}</div>
      </div>
                            <div class="now-playing-plays">${playcount.toLocaleString()} ${playcount === 1 ? 'play' : 'plays'}</div>
      </div>
                        </a>
                      `;
                    }).join('');
                    nowPlayingDiv.innerHTML = existingHtml + newHtml;
                  });
                }
              })
              .finally(() => {
                isLoadingMore = false;
              });
          } else if (currentView === 'tracks') {
            loadTopTracks(currentPage.tracks + 1, true).finally(() => {
              isLoadingMore = false;
            });
          } else if (currentView === 'albums') {
            loadTopAlbums(currentPage.albums + 1, true).finally(() => {
              isLoadingMore = false;
            });
          } else if (currentView === 'artists') {
            loadTopArtists(currentPage.artists + 1, true).finally(() => {
              isLoadingMore = false;
            });
          }
        }
      });
    }

    // Username form handler
    document.getElementById('username-form').addEventListener('submit', (e) => {
      e.preventDefault();
      const username = document.getElementById('username-field').value.trim();
      if (username) {
        LASTFM_USERNAME = username;
        localStorage.setItem('lastfm_username', username);
        document.getElementById('username-input').style.display = 'none';
        document.getElementById('change-username-btn').style.display = 'block';
        // Show all views
        document.querySelectorAll('.stats-view').forEach(v => v.style.display = '');
        document.querySelector('.stats-view-switcher').style.display = 'flex';
        document.getElementById('time-period-selector').style.display = 'flex';
        loadViewData();
        setupInfiniteScroll();
      }
    });

    // Initial load and setup event listeners
    document.addEventListener('DOMContentLoaded', () => {
      // Change username button handler
      const changeUserBtn = document.getElementById('change-username-btn');
      if (changeUserBtn) {
        changeUserBtn.addEventListener('click', () => {
          LASTFM_USERNAME = '';
          localStorage.removeItem('lastfm_username');
          document.getElementById('username-input').style.display = 'flex';
          document.getElementById('change-username-btn').style.display = 'none';
          document.getElementById('username-field').value = '';
          // Hide all views
          document.querySelectorAll('.stats-view').forEach(v => v.style.display = 'none');
          document.querySelector('.stats-view-switcher').style.display = 'none';
          document.getElementById('time-period-selector').style.display = 'none';
        });
      }
      
      if (LASTFM_USERNAME) {
        document.getElementById('username-input').style.display = 'none';
        document.getElementById('change-username-btn').style.display = 'block';
        loadViewData();
        setupInfiniteScroll();
      } else {
        document.getElementById('username-input').style.display = 'flex';
        document.getElementById('change-username-btn').style.display = 'none';
        // Hide all views until username is entered
        document.querySelectorAll('.stats-view').forEach(v => v.style.display = 'none');
        document.querySelector('.stats-view-switcher').style.display = 'none';
        document.getElementById('time-period-selector').style.display = 'none';
      }
    });
  </script>

</body>
</html> 
